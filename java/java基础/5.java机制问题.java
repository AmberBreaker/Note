1.	栈、堆
	栈：存储的都是局部变量（函数中定义的变量，函数上的参数，语句中的变量）；只要数据运算完成所在的区域结束，该数据就会被释放。
	堆：用于存储数组、成员变量和对象，也就是实体。啥是实体啊？就是用于封装多个数据的。

2.	创建一个对象都在内存中做了什么事情？
	public class Test {
		public static void main(String[] args) {
			Person p = new Person("zhangsan");
		}
	}
	public class Person {
		private String name;
		public Person(String name) {
			this.name = name;
		}
		public String getName() {
			return this.name;
		}
	}
	1	先将硬盘上指定位置的 Person.class 文件加载进内存。
	2	执行 main 方法时，在栈内存中开辟了 main 方法的空间（压栈 - 进栈），然后在 main 方法的栈区分配了一个变量 p。
	3	在堆内存中开辟一个实体空间，分配了一个内存首地址值。
	4	在该实体空间中进行属性的空间分配，并进行了默认初始化。
	5	对空间中的属性进行显式初始化。
	6	进行实体的构造代码块初始化。
	7	调用该实体对应的构造函数，进行构造函数初始化。
	8	将首地址赋值给 p，p 变量就引用了该实体。（指向了该对象）

3.	保留字 this
	this 代表对象。就是所在函数所属对象的引用。
	1	this对象后面跟上 . 调用的是成员属性和成员方法(一般方法)；
		this.name 、 this.getName()
	2	this对象后面跟上 () 调用的是本类中的对应参数的构造函数。 this()
		*	用 this 调用构造函数，必须定义在构造函数的第一行。因为构造函数是用于初始化的，
			所以初始化动作一定要执行。否则编译失败。

4.	关键字 static
	修饰符，用于修饰成员(成员变量和成员函数)。
	1	想要实现对象中的共性数据的对象共享。可以将这个数据进行静态修饰。
	2	被静态修饰的成员，可以直接被类名所调用。也就是说，静态的成员多了一种调用方式。类名.静态方式。
	3	静态随着类的加载而加载。而且优先于对象存在。
	4	静态方法只能访问静态成员，不可以访问非静态成员。
	5	静态方法中不能使用 this , super 关键字。因为 this 代表对象，而静态在时，有可能没有对象，所以 this 无法使用。

5.	成员变量和静态变量的区别
	1	成员变量所属于对象，所以也称为实例变量；静态变量所属于类，所以也称为类变量。
	2	成员变量存在于堆内存中；静态变量存在于方法区中。
	3	成员变量随着对象创建而存在，随着对象被回收而消失；静态变量随着类的加载而存在，随着类的消失而消失。
	4	成员变量只能被对象所调用；静态变量可以被对象调用，也可以被类名调用。
	所以，成员变量可以称为对象的特有数据，静态变量称为对象的共享数据。

6.	继承的一个弊端：打破了封装性。对于一些类，或者类中功能，是不能被继承，或者复写的。
	这时如何解决问题呢？介绍一个关键字，final。
	final特点：
	1	这个关键字是一个修饰符，可以修饰类，方法，变量。
	2	被final修饰的类是一个最终类，不可以被继承。
	3	被final修饰的方法是一个最终方法，不可以被覆盖。
	4	被final修饰的变量是一个常量，只能赋值一次。

7.	内部类
	class Outer {
		int num = 4;

		/**
		 * 内部类，可以使用一些成员修饰符修饰：private，static等
		 * 1. 默认修饰符(protected)，一般用的比较少
		 * 	  Outer.Inner in = new Outer.new Inner();
		 * 2. 私有修饰符(private)
		 *	  通常内部类被封装，都会被私有化，因为封装性不让其他程序直接访问。
		 * 3. 静态修饰符
		 *	  如果内部类被静态修饰，相当于外部类，会出现访问局限性，只能访问外部类中的静态成员。
		 */
		class Inner {
			void show() {
				System.out.println("inner show run " + num);
			}
		}

		public void method() {
			/*创建内部类的对象*/
			Inner in = new Inner();
			/*调用内部类的方法*/
			in.show();
		}
	}
	1	内部类编译后的文件名为：“Outer$Innerjava”
	2	匿名内部类
		没有名字的内部类。就是内部类的简化形式。一般只用一次就可以用这种形式。匿名内部类其实就是一个匿名子类对象。
		想要定义匿名内部类需要前提：内部类必须继承一个类或者实现接口。
		匿名内部类的格式：new 父类名&接口名(){ 定义子类成员或者覆盖父类方法 }.方法。
		当函数的参数是接口类型引用时，如果接口中的方法不超过3个。可以通过匿名内部类来完成参数的传递。
		其实就是在创建匿名内部类时，该类中的封装的方法不要过多，最好两个或者两个以内。

8.	