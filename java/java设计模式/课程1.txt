*	课程主题
	|--	设计原则
	|--	设计模式中的几种案例

*	课程目标
	|--	理解七大设计原则
	|--	整体理解面向对象设计模式（3类23种）
	|--	创建型设计模式学习1（工厂、原型、构建者）
	|--	创建型设计模式学习2（单例）

*	课程回顾
	|--	完成mybatis3.0版本的编写
	|--	阅读mybatis官方源码（如何阅读源码）


**	课程内容
	|--	简单了解UML中的类图
	|	|--	类或者接口的类图表示方式。
	|	|--	类与类之间的继承关系和实现关系是如何表示的。
	|
	|--	理解七大设计原则（可以提升面向对象的设计能力）

*	七大设计原则：
	|--	【开闭原则】：开闭原则是七大原则中最根本的原则。
	|	|--	类或者方法中的代码，要【对扩展开放】，要【对修改关闭】。
	|	|	|--	【对扩展开放】：如【抽象并实现继承关系】、【面向接口编程，解耦】、【配置文件】等。《eg1：对扩展开放》
	|	|	|--	【对修改关闭】：《eg2：对修改关闭范例》
	|	|--	开闭原则使用的前提是该部分代码已经封板，或者已经上线使用了，这也是很多公司都不允许在代码中写【硬编码】的原因。如数据库的连接。
	|	|--	为了提升代码的可扩展性。
	|	|
	|--	【里氏替换原则】：如何合理地使用继承关系。
	|	|--	任何能出现父类的地方，替换成子类之后代码依然正常运行，包括里面的逻辑。
	|	|--	子类必须要实现父类的抽象方法，子类不要去重写父类的非抽象方法。
	|	|--	【抽象模版方法模式】就是遵循里氏替换原则的一个模式。
	|	
	|--	【依赖倒置原则】：强调要面向接口、面向抽象进行编程。
	|	|--	抽象不应该依赖细节，而细节应该依赖抽象：我们要抽象一个类或者方法的时候，先不要去考虑怎么实现，而应该直接考虑该功能怎么设计。
	|	|--	建议类的【成员变量】、类的【方法型参】、类的【返回值类型】，都采用【接口类型】或者【抽象类型】。
	|	|--	如Service层和Dao层就是通过Dao接口进行编程的。
	|
	|--	【单一职责原则】：如何去定义一个面向对象的类。
	|	|--	一个类是由【内在的属性】和【外在的行为】形成。
	|	|--	不要让一个类干太多的事情，这样不方便类的复用性。
	|	|--	单一职责原则是最难使用的原则，因为如何去对内在的属性和外在的行为进行分类汇总，是一件非常需要经验的事情。
	|
	|--	【接口隔离原则】：如何去定义一个面向对象的接口类。
	|	|--	接口主要是为了给【类】级别去提供增强的功能。
	|	|--	Spring中特别明显。
	|
	|--	【合成复用原则】：能用【关联关系（聚合、组合）】就不要使用【继承关系】
	|	
	|--	【迪米特法则】：也叫【最少认知原则】。高内聚，低耦合。
		|--	不要和陌生人说话。


*	创建型设计模式：
	为什么要使用创建型设计模式：
	|->	Student stu = new Student(// 10个参数);
	|--	我们不希望去处理过多的构建细节，那么就将细节交给专业人士去处理，“创建型设计模式”就是这个专业的人士。
	|--	当一些类是通过第三方jar包引用的，如BasicDataSource，我们不清楚其具体的构造细节。


	|--	简单工厂
	|	|--	只有一个工厂类
	|	|--	可以生产任何需要的对象，也称之为上帝工厂或万能工厂。
	|
	|--	工厂方法
	|	|--	会有多个工厂，针对不同需求，可以创造不同的工厂。
	|	|--	工厂会是多个，但生产的产品只有一个
	|	|--	和简单工厂不同，先有构造工厂的方法（接口），再根据标准去建立工厂，由这个工厂去生产不同的产品（产品在工厂方法中是抽象的）。
	|
	|--	抽象工厂
	|	|--	工厂会是多个，生产的产品也会是多个，并且这些产品属于一个产品簇。
	|	|--	其他内容与工厂方法一致

*	构建者模式
	|--	与工厂模式异同：
	|	|--	相同点：都是为了创造对象
	|	|--	不同点：工厂模式更多的是批量创建相同的对象，而构建者模式是根据调用者具体的需求而定制的私人对象。
	|
	|--	构建者模式中的角色：
	|	|--	产品类：需要生产的对象。
	|	|--	导演类：导演如何去定制一个对象。
	|	|--	构建者类：完成私人定制功能的具体类。




====================== Examples ======================
eg1：对扩展开放：
	public class MyTest {
		private Bird bird;
		public void setBird(Bird bird) {
			this.bird = bird;
		}

		public void testFly() {
			bird.fly();
		}
	}

eg2：对修改关闭范例：
	设计之初，我们使用的是MySql数据库，获取Connection方法如下
	public Connection getConnection() {
		Class.forName("com.mysql.jdbc.Driver");
		...
	}
	之后的需求需要改成Oracle数据库，则此时需要修改代码，这是典型的违反了开闭原则范例